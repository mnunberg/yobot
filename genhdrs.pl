#!/usr/bin/perl
use Getopt::Std;
getopts("vi:o:");
if(!($opt_i && $opt_o)) {
	die("Need -i and -o!\n");
}
sub debug {
	my $old_flushconf = $|;
	$|=1;
	if ($opt_v) {
		print STDERR "$0: $_[0]\n";
	}
	$|=$old_flushconf;
}

debug("opening $opt_i");
open(EXISTING_SWIGFILE, "<$opt_i") || die("Couldn't open $opt_i: $!\n");
$existing_swigfile;
for $line (<EXISTING_SWIGFILE>) {
	$existing_swigfile .= $line;
}
close(EXISTING_SWIGFILE);


debug("Scanning for purple directory using pkg-config");
$purple_dir = `pkg-config purple --cflags-only-I` || die("oops");
$purple_dir =~ m/I([\w\/]*purple[\w*\/]*)/ || die "Couldn't find libpurple headers";
$purple_dir = $1 . "/";
$bar = [
	["conversation", "PurpleMessageFlags"],
	["status", "PurpleStatusPrimitive"],
	["proxy", "PurpleProxyType"]];

@generated_header = ();

foreach my $b (@$bar) {
	$headerfile = $purple_dir . $$b[0] . ".h";
	$enumtype = $$b[1];
	open(HDR, $headerfile) || die("Couldn't open file $headerile\n");
	debug("extracting $enumtype from $headerfile");
	$hdrdata = "";
	for $line (<HDR>) {
		$hdrdata .= $line;
	}
	$hdrdata =~ m/(typedef\s*enum\s*\{\s*[^\}]*\}\s*$enumtype\;)/ || die(
		"couldn't find enum $enumtype in $headerfile");
	push @generated_header,$1 . "\n\n";
	close(HDR);
}

open(OUTFILE, "+>", $opt_o) || die $!;

print OUTFILE  "/*Automatically generated by the Yobot Build process*/\n" .
		"/*Contents from $headerfile*/\n";
print OUTFILE $existing_swigfile;
print OUTFILE "\n@generated_header\n";
seek(OUTFILE, 0, SEEK_SET);
#$out_txt; for $line (<OUTFILE>) { $out_txt .= $line; }; debug($out_txt);
close(OUTFILE);
